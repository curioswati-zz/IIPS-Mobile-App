{
  "name": "umzug",
  "version": "1.6.0",
  "description": "Framework agnostic migration tool for Node.JS",
  "main": "index.js",
  "dependencies": {
    "bluebird": "^2.3.10",
    "lodash": "^3.0.1",
    "moment": "^2.8.3",
    "redefine": "^0.2.0",
    "resolve": "^1.0.0"
  },
  "devDependencies": {
    "coffee-script": "^1.8.0",
    "expect.js": "^0.3.1",
    "gulp": "^3.8.10",
    "gulp-mocha": "^2.0.0",
    "mocha": "^2.0.1",
    "sequelize": "^2.0.0-rc3",
    "sinon": "^1.11.1",
    "sqlite3": "^3.0.2",
    "yargs": "^1.3.2"
  },
  "scripts": {
    "test": "gulp"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/sequelize/umzug.git"
  },
  "author": "",
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/sequelize/umzug/issues"
  },
  "homepage": "https://github.com/sequelize/umzug",
  "readme": "# Umzug [![Build Status](https://travis-ci.org/sequelize/umzug.svg?branch=master)](https://travis-ci.org/sequelize/umzug)\nThe *umzug* lib is a framework agnostic migration tool for Node.JS. The tool itself is not specifically related to databases but basically provides a clean API for running and rolling back tasks.\n\n## Persistence\nIn order to keep track of already executed tasks, *umzug* logs successfully executed migrations. This is done in order to allow rollbacks of tasks. There are multiple storage presets available, from which you can choose. Adding a custom is  super simple as well.\n\n## Storages\n\n### JSON\nUsing the [`json` storage](lib/storages/json.js) will create a JSON file which will contain an array with all the executed migrations. You can specify the path to the file. The default for that is `umzug.json` in the working directory of the process.\n\n#### Options\n\n```js\n{\n  // The path to the json storage.\n  // Defaults to process.cwd() + '/umzug.json';\n  path: process.cwd() + '/db/sequelize-meta.json'\n}\n```\n\n### Sequelize\nUsing the [`sequelize` storage](lib/storages/sequelize.js) will create a table in your database called `SequelizeMeta` containing an entry for each executed migration. You will have to pass a configured instance of Sequelize or an existing Sequelize model. Optionally you can specify the model name, table name, or column name.\n\n#### Options\n\n```js\n{\n  // The configured instance of Sequelize.\n  // Optional if `model` is passed.\n  sequelize: instance,\n\n  // The to be used Sequelize model.\n  // Must have column name matching `columnName` option\n  // Optional of `sequelize` is passed.\n  model: model,\n\n  // The name of the to be used model.\n  // Defaults to 'SequelizeMeta'\n  modelName: 'Schema',\n\n  // The name of table to create if `model` option is not supplied\n  // Defaults to `modelName`\n  tableName: 'Schema',\n\n  // The name of table column holding migration name.\n  // Defaults to 'name'.\n  columnName: 'migration',\n\n  // The type of the column holding migration name.\n  // Defaults to `Sequelize.STRING`\n  columnType: new Sequelize.STRING(100)\n}\n```\n\n### Custom\nIn order to use a custom storage, you can create and publish a module which has to fulfill the following API. You can just pass the name of the module to the configuration and *umzug* will require it accordingly. The API that needs to be exposed looks like this:\n\n```js\nvar Bluebird = require('bluebird');\nvar redefine = require('redefine');\n\nmodule.exports = redefine.Class({\n  constructor: function (options) {\n    this.options = options;\n    this.options.storageOptions = _.extend({\n      option1: 'defaultValue1'\n    }, this.options.storageOptions)\n  },\n\n  logMigration: function (migrationName) {\n    return new Bluebird(function (resolve, reject) {\n      // This function logs a migration as executed.\n      // It will get called once a migration was\n      // executed successfully.\n    });\n  },\n\n  unlogMigration: function (migrationName) {\n    return new Bluebird(function (resolve, reject) {\n      // This function removes a previously logged migration.\n      // It will get called once a migration has been reverted.\n    });\n  },\n\n  executed: function () {\n    return new Bluebird(function (resolve, reject) {\n      // This function lists the names of the logged\n      // migrations. It will be used to calculate\n      // pending migrations. The result has to be an\n      // array with the names of the migration files.\n    });\n  }\n});\n```\n\n## Migrations\nMigrations are basically files that describe ways of executing and reverting tasks. In order to allow asynchronicity, tasks have return a Promise object which provides a `then` method.\n\n### Format\nA migration file ideally contains an `up` and a `down` method, which represent a function which achieves the task and a function that reverts a task. The file could look like this:\n\n```js\n'use strict';\n\nvar Bluebird = require('bluebird');\n\nmodule.exports = {\n  up: function () {\n    return new Bluebird(function (resolve, reject) {\n      // Describe how to achieve the task.\n      // Call resolve/reject at some point.\n    });\n  },\n\n  down: function () {\n    return new Bluebird(function (resolve, reject) {\n      // Describe how to revert the task.\n      // Call resolve/reject at some point.\n    });\n  }\n};\n```\n\n## Usage\n\n### Installation\nThe *umzug* lib is available on npm:\n\n```js\nnpm install umzug\n```\n\n### API\nThe basic usage of *umzug* is as simple as that:\n\n```js\nvar Umzug = require('umzug');\nvar umzug = new Umzug({});\n\numzug.someMethod().then(function (result) {\n  // do something with the result\n});\n```\n\n#### Executing migrations\nThe `execute` method is a general purpose function that runs for every specified migrations the respective function.\n\n```js\numzug.execute({\n  migrations: ['some-id', 'some-other-id'],\n  method: 'up'\n}).then(function (migrations) {\n  // \"migrations\" will be an Array of all executed/reverted migrations.\n});\n```\n\n#### Getting all pending migrations\nYou can get a list of pending/not yet executed migrations like this:\n\n```js\numzug.pending().then(function (migrations) {\n  // \"migrations\" will be an Array with the names of\n  // pending migrations.\n});\n```\n\n#### Getting all executed migrations\nYou can get a list of already executed migrations like this:\n\n```js\numzug.executed().then(function (migrations) {\n  // \"migrations\" will be an Array of already executed migrations.\n});\n```\n\n#### Executing pending migrations\nThe `up` method can be used to execute all pending migrations.\n\n```js\numzug.up().then(function (migrations) {\n  // \"migrations\" will be an Array with the names of the\n  // executed migrations.\n});\n```\n\nIt is also possible to pass the name of a migration in order to just run the migrations from the current state to the passed migration name.\n\n```js\numzug.up({ to: '20141101203500-task' }).then(function (migrations) {});\n```\n\nRunning specific migrations while ignoring the right order, can be done like this:\n\n```js\numzug.up({ migrations: ['20141101203500-task', '20141101203501-task-2'] });\n```\n\nThere are also shorthand version of that:\n\n```js\numzug.up('20141101203500-task'); // Runs just the passed migration\numzug.up(['20141101203500-task', '20141101203501-task-2']);\n```\n\nRunning\n\n#### Reverting executed migration\nThe `down` method can be used to revert the last executed migration.\n\n```js\numzug.down().then(function (migration) {\n  // \"migration\" will the name of the reverted migration.\n});\n```\n\nIt is possible to pass the name of a migration until which the migrations should be reverted. This allows the reverse of multiple migrations at once.\n\n```js\numzug.down({ to: '20141031080000-task' }).then(function (migrations) {\n  // \"migrations\" will be an Array with the names of all reverted migrations.\n});\n```\n\nReverting specific migrations while ignoring the right order, can be done like this:\n\n```js\numzug.down({ migrations: ['20141101203500-task', '20141101203501-task-2'] });\n```\n\nThere are also shorthand version of that:\n\n```js\numzug.down('20141101203500-task'); // Runs just the passed migration\numzug.down(['20141101203500-task', '20141101203501-task-2']);\n```\n\n### Configuration\n\nIt is possible to configure *umzug* instance via passing an object to the constructor. The possible options are:\n\n```js\n{\n  // The storage.\n  // Possible values: 'json', 'sequelize', an object\n  storage: 'json',\n\n  // The options for the storage.\n  // Check the available storages for further details.\n  storageOptions: {},\n\n  // The logging function.\n  // A function that gets executed everytime migrations start and have ended.\n  logging: false,\n\n  // The name of the positive method in migrations.\n  upName: 'up',\n\n  // The name of the negative method in migrations.\n  downName: 'down',\n\n  migrations: {\n    // The params that gets passed to the migrations.\n    // Might be an array or a synchronous function which returns an array.\n    params: [],\n\n    // The path to the migrations directory.\n    path: 'migrations',\n\n    // The pattern that determines whether or not a file is a migration.\n    pattern: /^\\d+[\\w-]+\\.js$/,\n\n    // A function that receives and returns the to be executed function.\n    // This can be used to modify the function.\n    wrap: function (fun) { return fun; }\n  }\n}\n```\n\n## License\nMIT\n",
  "readmeFilename": "README.md",
  "_id": "umzug@1.6.0",
  "_from": "umzug@^1.6.0"
}
